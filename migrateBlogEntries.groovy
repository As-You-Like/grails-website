/*
 * This is a hacky script to convert blog_entry records in the grails.org
 * database to content ones (or more specifically, NewsItem domain instances).
 * You need to run it with:
 *
 *     grails run-script migrateBlogEntries.groovy
 *
 * in whatever environment defines the database you want to migrate.
 *
 * The blog_entry records contain messy, messy HTML generated by a web rich
 * text editor, whereas NewsItem uses gdoc wiki syntax. So, this script uses
 * Jsoup to process the HTML, strip out the rubbish, and perform a simple
 * conversion of content -> wiki syntax. It's pretty rough, but works well
 * enough for most of the news items.
 */
@Grab(group="org.jsoup", module="jsoup", version="1.6.3")
import org.jsoup.Jsoup
import org.jsoup.nodes.Comment
import org.jsoup.nodes.Element
import org.jsoup.nodes.TextNode

import org.joda.time.DateTime
import groovy.sql.Sql
import org.grails.auth.User
import org.grails.news.NewsItem

def sql = new Sql(ctx.getBean("dataSource"))

authors = [:]

disableAutoTimestamping(new NewsItem())

println "Processing ${sql.firstRow('select count(*) from blog_entry')[0]} blog entries"

NewsItem.withNewSession {
    sql.eachRow("SELECT * from blog_entry") { r ->
        print "Processing item '${r.title}'"
        new NewsItem(
                author: getUser(r.author),
                body: convertContent(r.body),
                title: r.title,
                dateCreated: new DateTime(r.date_created),
                lastUpdated: new DateTime(r.last_updated),
                status: "APPROVED").save(failOnError: true)
    }
}

println "Done"

def disableAutoTimestamping(instance) {
    def closureInterceptor = ctx.getBean("eventTriggeringInterceptor")
    def datastore = closureInterceptor.datastores.values().iterator().next()
    def interceptor = datastore.getEventTriggeringInterceptor()

    def listener = interceptor.findEventListener(instance)
    listener.shouldTimestamp = false
}

def getUser(username) {
    def user = authors[username]
    if (!user) {
        user = User.findByLogin(username)
        authors[username] = user
    }
    return user
}

def convertContent(content) {
    def body = Jsoup.parseBodyFragment(content).body()
    def conversionBuffer = new StringBuilder(content.size())

    for (node in body.childNodes()) {
        processNode node, conversionBuffer
    }

    return conversionBuffer.toString()
}

def processNode(Element element, conversionBuffer) {
    switch (element.tagName()) {
    case "span":
    case "font":
        for (node in element.childNodes()) {
            processNode node, conversionBuffer
        }
        break

    case "div":
    case "p":
        conversionBuffer << "\n"
        for (node in element.childNodes()) {
            processNode node, conversionBuffer
        }
        conversionBuffer << "\n"
        break

    case "ul":
        conversionBuffer << "\n"
        for (e in getLiChildren(element)) {
            processListItem(e, conversionBuffer, "*")
        }
        conversionBuffer << "\n"
        break

    case "ol":
        conversionBuffer << "\n"
        for (e in getLiChildren(element)) {
            processListItem(element, conversionBuffer, "#")
        }
        conversionBuffer << "\n"
        break

    case "a":
        conversionBuffer << "[${element.text()}|${processLink(element.attr('href'))}]"
        break

    case "br":
        conversionBuffer << "\n\n"
        break

    default:
        break
    }
}

def processNode(TextNode node, conversionBuffer) {
    conversionBuffer << node.text()
}

def processNode(Comment node, conversionBuffer) {
    // Ignore comments.
}

def processListItem(Element element, conversionBuffer, String prefix) {
    conversionBuffer << prefix << " "

    for (node in element.childNodes()) {
        processNode node, conversionBuffer
    }

    conversionBuffer << "\n"
}

def getLiChildren(Element e) {
    return e.children().findAll { it.tagName() == "li" }
}

def processLink(link) {
    if (link.startsWith('/')) return "http://grails.org" + link
    else return link
}
